from ultralytics import YOLO
import cv2
import numpy as np

MODEL_PATH = 'models\yolov8s_playing_cards.pt'

def detect_cards(image_path):
    #load yolo model
    model = YOLO(MODEL_PATH)

    #rescale image to match YOLO's training size
    image = rescale_stretch(image_path)

    #run inference
    results = model(image, verbose=False)[0]

    detections = []

    for box in results.boxes:
        cls = int(box.cls[0])
        conf = float(box.conf[0])
        xyxy = box.xyxy[0].tolist()  # [x1, y1, x2, y2]

        detections.append({
            "class_id": cls,
            "class_name": model.model.names[cls],
            "confidence": conf,
            "box": xyxy
        })

    return detections

#debbuging, draw detections
def draw_detections(image_path, detections):
    image = cv2.imread(image_path)

    image = rescale_stretch(image)

    for det in detections:
        x1, y1, x2, y2 = map(int, det["box"])
        label = f"{det['class_name']} {det['confidence']:.2f}"

        cv2.rectangle(image, (x1, y1), (x2, y2), (0, 0, 255), 5)
        cv2.putText(image, label, (x1, y1 - 10), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2)
    
    cv2.imwrite("output/yolo.jpg", image)

#letterbox rescale - generated by Gemini 3
def rescale_letterbox(img, new_shape=(640, 640), color=(114, 114, 114)):    
    # Get original image shape (height, width)
    h, w = img.shape[:2]
    
    # Calculate scale ratio (r) and new unpadded dimensions
    r = min(new_shape[0] / h, new_shape[1] / w)
    nw, nh = int(w * r), int(h * r)
    
    # Resize image
    img = cv2.resize(img, (nw, nh), interpolation=cv2.INTER_LINEAR)
    
    # Calculate padding
    dw, dh = new_shape[1] - nw, new_shape[0] - nh  # width and height padding
    top, bottom = dh // 2, dh - dh // 2
    left, right = dw // 2, dw - dw // 2
    
    # Apply padding
    img = cv2.copyMakeBorder(img, top, bottom, left, right, cv2.BORDER_CONSTANT, value=color)
    
    # Normalize and return
    return img.astype(np.float32)

#streth rescale
def rescale_stretch(image, size=(640, 640)):
    return cv2.resize(image, size, interpolation=cv2.INTER_LINEAR)

#turn card detections into a set of cards
def format_cards(detections):
    cards = []
    for detection in detections:

        #filter out low confidence
        if detection['confidence'] < 0.4:
            continue

        card = detection['class_name']

        #handle '10' (pokerkit needs 'T')
        if detection['class_name'][0] == '1':
            card = 'T' + detection['class_name'][2].lower()
        else:
            #format like 'Ah' (Ace of Hearts)
            card = card[0] + card[1].lower()

        #make second letter (suit) lowercase
        cards.append(card)
    
    #remove duplicates
    cards = list(set(cards))
    
    return cards

if __name__ == "__main__":

    image_path = "test_images/riverandhand.png"
    image = cv2.imread(image_path)

    detections = detect_cards(image)

    # save detections - DEBUG
    draw_detections(image_path, detections)

    # print("Detections:")
    for d in detections:
        print(d)

    cards = format_cards(detections)
    print("Detected cards:", cards)


